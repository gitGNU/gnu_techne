Closing the Lua state on exit:
==============================

Closing the Lua state calls all finalizers on exit and frees memory
resources.  Normaly only entirely unlinked nodes can be collected but
this doesn't hold on exit, therefore heap corruption if a node's
linkage changes and one of the nodes it points to has been collected.
This needs to be addressed if closing the Lua state on exit proves
necessary.

Porting/cross-compiling:
========================

* graphics.window is initially {0, 0}
* win32 port crashes when trying to set window size
* version number should be augmented by platform if possible.
* autoconf check for whether the terminal supports color output.

Techne can be configured for cross-compiling like this:

LUA_CFLAGS='-I/usr/local/mingw/include' LUA_LIBS='-L/usr/local/mingw/lib -llua -lm' MHD_CFLAGS='-I/usr/local/mingw/include' MHD_LIBS='-L/usr/local/mingw/lib -lmicrohttpd' ./configure --build=x86_64-linux-gnu --host=i686-pc-mingw32

Nodes with static data
======================

Nodes that need to have part of their configuration set beforehand and not subject to change must do so through a mold node.  This should read in a table with the static configuration on init and provide constructor functions like a regular module.  On free all static data should be freed.  Every node constructed by the moold should expect to find a the userdata of the mold node at the top of the stach from which it can copy the static configuration and to which it should make a reference so as to prevent its premature collection.

TODO (eventually):
==================

* Fix the manual page.
* Make network page functions return {mime, page} instead of page.
* Consider moving luaarray, luaprompt to github.
* Consider automatically invoking the GDB when something goes wrong.

TODO (ASAP):
============

* Fix the chain node to properly reflect the velocity when the run changes.
* Add a Lua texture object wrapper.
* Replace state getters in all nodes that have them with individual read-only
  attributes.
* Figure out how to avoid having to write things such as
  topography.elevationMold {...}.
* Adapt the Racetrack node to the mold node approach.
* Figure out how to handle sampling the elevation data for contact detection.
* Add an ElevationShading node.